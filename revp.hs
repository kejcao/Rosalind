-- https://rosalind.info/problems/revp/

import Data.List (findIndices)

input = "GCGCAGCCATCCTTTGTCGTCGATCCATGAATGTCTATGTGGAACCCAGGCGAGTGGTTCGGTCGTCTGTAGTAAATACAATGCAGTTCCCTACGAATTATTCCCATCCGCGATCGGTCCAATCGGTTCCAAAAACGCATTCACTGCCGACTCAAGATTCAGCTGGCACCTCTCCTAGGAGGTGGACTATGAGACATGAAAAAGTTCAATACATGTGTTCGAGAGTGGAGTCCCTTGCTAGCAATAATGTGCCGCTTAGGTATTGAAGGCGGTATTCTGTGGCAGGACGTCTGGGGTATTCGGGTATGTCCTGATTATTTGTATTCGTGCGATATGAACGAACCCCCCTACGTACTCCTCAATCCTTGTTTCATTCTTCCAGACATCGGGGCTAGCGCGAACGTATGCTTTAAGAACCCGTGCCGGTAAAACGTTTATTTCAACCATCGCTAATCATATGATTACGGTCCATAAAGTGGGCCTTATCTAACTTTGATGGTCCGGTTGGGTCTAGGGAACTTATTCCCGTGGCTTAGGCATGCCCCGTTACCCAAAGTTAAATCGAAACTGCTTCGTGAAGGGCTCAGACTGCGATACCCTGCGCCAGGTGCTACCCGTAGACCTTGGCGTGAATACTTAGGCATCTGACTATACGCTTACGAGTCTTGGCCGCTCTGTTCGCCTTTGAGATGTCTCTGTTAGTCGCAGGATTGGTGGTCAGAGTTGAGTCCAGGTCCATACTGCTGGTGGCTCTAGGACTGCTTTGAGTTTGCTTTCCGATCTCGGTCCATCCATTAATGGAACACCATTGCGGATCCGGATCTGACAGCCCGGTGTGAGTACAGTACCCCCATAAGTTTCCCTTCAATGCAGCAATCTTCTAGCCTTGCTTACCCATCGATTTAATGGTATAT"

f 'A' = 'T'
f 'T' = 'A'
f 'C' = 'G'
f 'G' = 'C'

complement s = reverse $ map f s

chunk :: Int -> [a] -> [[a]]
chunk n l =
  if n > length l
    then []
    else take n l : chunk n (tail l)

reversePalindromesOfLength n = map (\x -> [x + 1, n]) $ findIndices id $ zipWith (==) l (map complement l)
  where
    l = chunk n input

main = mapM_ (putStrLn . unwords . map show) $ concatMap reversePalindromesOfLength [4 .. 12]
